import { Client } from 'pg';
import { DBDriver, CreateTableOptions } from "./driver";
import { CreateOptions, ReadOptions, UpdateOptions, DeleteOptions } from "../types";
import { buildWhere, buildQueryTail } from './sqlConstructor';

class PostgresDriver implements DBDriver {
  private client!: Client;

  async connect(options: { host: string; port: number; user: string; password: string; database: string }): Promise<void> {
    this.client = new Client(options);
    await this.client.connect();
  }

  async disconnect () {
    this.client.end();
  }

  async create<T = unknown>(table: string, data: Partial<T>): Promise<void> {
    const fields = Object.keys(data);
    const values = Object.values(data);

    if (fields.length === 0) {
      throw new Error('No data provided for insert');
    }

    const placeholders = values.map((_, i) => `$${i + 1}`).join(', ');
    const sql = `INSERT INTO "${table}" (${fields.map(f => `"${f}"`).join(', ')}) VALUES (${placeholders})`;

    await this.client.query(sql, values);
  }

  async read<T = unknown>(table: string, options?: ReadOptions<T>): Promise<T[]> {
    let fieldsSql = '*';

    if (options?.fields) {
      fieldsSql = options.fields.map(f => `"${f as string}"`).join(', ');
    }

    let whereSql = '';
    let whereParams: unknown[] = [];

    if (options?.where) {
      const parsed = buildWhere(options.where, 'postgres');
      whereSql = parsed.sql;
      whereParams = parsed.params;
    }

    const sql = `SELECT ${fieldsSql} FROM "${table}"${whereSql ? ' ' + whereSql : ''}${buildQueryTail(options)}`;
    const result = await this.client.query(sql, whereParams);
    return result.rows as T[];
  }

  async update<T = unknown>(table: string, data: Partial<T>, options?: UpdateOptions<T>): Promise<void> {
    const fields = Object.keys(data);
    const values = Object.values(data);

    if (fields.length === 0) {
      throw new Error('No data provided for update');
    }

    const setClause = fields.map((f, i) => `"${f}" = $${i + 1}`).join(', ');

    let whereSql = '';
    let whereParams: unknown[] = [];

    if (options?.where) {
      const parsed = buildWhere(options.where, 'postgres');
      whereSql = parsed.sql;
      whereParams = parsed.params;
    }

    const sql = `UPDATE "${table}" SET ${setClause}${whereSql ? ' ' + whereSql : ''}`;
    await this.client.query(sql, [...values, ...whereParams]);
  }

  async delete<T = unknown>(table: string, options?: DeleteOptions<T>): Promise<void> {
    let whereSql = '';
    let whereParams: unknown[] = [];

    if (options?.where) {
      const parsed = buildWhere(options.where, 'postgres');
      whereSql = parsed.sql;
      whereParams = parsed.params;
    }

    const sql = `DELETE FROM "${table}"${whereSql ? ' ' + whereSql : ''}`;
    await this.client.query(sql, whereParams);
  }

  async query<T = unknown>(sql: string, params?: unknown[]): Promise<void> {
    const result = await this.client.query(sql, params ?? []);
  }

  async queryWithResult<T = unknown>(sql: string, params?: unknown[]): Promise<T[]> {
    const result = await this.client.query(sql, params);
    return result.rows as T[];
  }

  async createTable(options: CreateTableOptions): Promise<void> {
    const fieldsSql = "id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, " + options.fields.join(', ');
    await this.client.query(`CREATE TABLE IF NOT EXISTS ${options.name} (${fieldsSql})`);
  }
}

export default PostgresDriver;